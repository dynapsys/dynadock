"""Handle generation of a *Caddyfile* and start/stop a Caddy container.

The Caddy reverse-proxy is optional and only required when TLS is enabled or
when sub-domain routing is desired. We run it in its own container so that the
host system does not need to have Caddy installed.
"""
from __future__ import annotations

import os
from pathlib import Path
from typing import Dict, List, Any

import docker
from jinja2 import Template

__all__ = ["CaddyConfig"]

# ---------------------------------------------------------------------------
# Default Caddyfile template – heavily inspired by the markdown docs
# ---------------------------------------------------------------------------

CADDYFILE_TEMPLATE = """
# Dynamic Caddyfile generated by DynaDock – do not edit manually ⚠️

{
    email admin@{{ domain }}
    {% if not enable_tls %}
    auto_https off
    {% endif %}
}

# Health endpoint on port 80 (always plain HTTP)
:80 {
    respond /health "OK" 200
}

{% if enable_tls %}
:443 {
    tls internal
}
{% endif %}

{% for service, port in services.items() %}
# ------------------------------
# Service: {{ service }}    ({{ port }})
# ------------------------------
{{ service }}.{{ domain }} {
    {% if enable_tls %}
    tls internal
    {% endif %}

    header {
        Access-Control-Allow-Origin "{{ cors_origins|join(', ') }}"
        Access-Control-Allow-Methods "GET,POST,PUT,DELETE,OPTIONS,PATCH"
        Access-Control-Allow-Headers "*"
        Access-Control-Allow-Credentials "true"
        Access-Control-Max-Age "3600"
    }

    @options method OPTIONS
    respond @options 204

    reverse_proxy {{ service }}:{{ port }} {
        health_uri /health
        health_interval 10s
        health_timeout 5s
    }

    log {
        output file /var/log/caddy/{{ service }}.log
        format json
        level info
    }
}
{% endfor %}
"""

# ---------------------------------------------------------------------------
# CaddyConfig helper
# ---------------------------------------------------------------------------


class CaddyConfig:  # pylint: disable=too-many-instance-attributes
    """Generate *Caddyfile* and manage the Caddy container."""

    def __init__(self, project_dir: Path):
        self.project_dir = Path(project_dir).resolve()
        self.caddy_dir = self.project_dir / ".dynadock" / "caddy"
        self.caddy_dir.mkdir(parents=True, exist_ok=True)

        self.client = docker.from_env()

    # ------------------------------------------------------------------
    # File generation helpers
    # ------------------------------------------------------------------

    def generate(
        self,
        services: Dict[str, Any],
        ports: Dict[str, int],
        domain: str,
        enable_tls: bool,
        cors_origins: List[str],
    ) -> Path:
        """Render template and write it to *Caddyfile* path."""
        template = Template(CADDYFILE_TEMPLATE)
        caddyfile_content = template.render(
            domain=domain,
            enable_tls=enable_tls,
            services=ports,
            cors_origins=cors_origins or [
                "http://localhost:3000",
                "http://localhost:5173",
                f"https://*.{domain}",
            ],
        )

        caddyfile_path = self.caddy_dir / "Caddyfile"
        with caddyfile_path.open("w", encoding="utf-8") as fp:
            fp.write(caddyfile_content)
        # ensure data/config/logs sub-dirs exist (for volume mounts)
        for sub in ("data", "config", "logs"):
            (self.caddy_dir / sub).mkdir(exist_ok=True)
        return caddyfile_path

    # ------------------------------------------------------------------
    # Container lifecycle helpers
    # ------------------------------------------------------------------

    _CONTAINER_NAME = "dynadock-caddy"

    def _container_exists(self) -> bool:
        try:
            self.client.containers.get(self._CONTAINER_NAME)
            return True
        except docker.errors.NotFound:
            return False

    def start_caddy(self):  # noqa: D401
        """Ensure a Caddy container is running and return the container obj."""
        # Remove existing container if it is stopped to avoid volume issues
        try:
            container = self.client.containers.get(self._CONTAINER_NAME)
            if container.status != "running":
                container.remove(force=True)
                raise docker.errors.NotFound("stopped", "container")
            return container
        except docker.errors.NotFound:
            pass  # will recreate

        # Start fresh container
        binds = {
            str(self.caddy_dir / "Caddyfile"): {
                "bind": "/etc/caddy/Caddyfile",
                "mode": "ro",
            },
            str(self.caddy_dir / "data"): {
                "bind": "/data",
                "mode": "rw",
            },
            str(self.caddy_dir / "config"): {
                "bind": "/config",
                "mode": "rw",
            },
            str(self.caddy_dir / "logs"): {
                "bind": "/var/log/caddy",
                "mode": "rw",
            },
        }

        container = self.client.containers.run(
            "caddy:2-alpine",
            name=self._CONTAINER_NAME,
            detach=True,
            restart_policy={"Name": "unless-stopped"},
            network_mode="bridge",
            ports={
                "80/tcp": 80,
                "443/tcp": 443,
                "2019/tcp": 2019,  # Admin API
            },
            volumes=binds,
            labels={
                "dynadock.managed": "true",
                "dynadock.component": "caddy",
            },
        )

        # Connect container to compose network (best-effort)
        self._connect_to_network(container)
        return container

    def stop_caddy(self) -> None:  # noqa: D401
        """Stop and remove the Caddy container if present."""
        try:
            container = self.client.containers.get(self._CONTAINER_NAME)
            container.stop()
            container.remove()
        except docker.errors.NotFound:
            pass

    # ------------------------------------------------------------------
    # Network helper
    # ------------------------------------------------------------------

    def _connect_to_network(self, container):  # type: ignore[no-self-use]
        # Try to hook into the default docker-compose network so that Caddy can
        # reach the service containers via their service names.
        for net in container.client.networks.list():
            if any(substr in net.name for substr in ("compose", "default")):
                try:
                    net.connect(container)
                    break
                except docker.errors.APIError:
                    pass
