"""Generate an *.env* file containing dynamic configuration for services.

The generator analyses the *services* section of the docker-compose file
and the dynamic port mapping returned by :class:`dynadock.port_allocator.PortAllocator`.
It writes all entries to *env_file* in the well-known ``dotenv`` format so
that they can be consumed by *docker-compose* (via ``--env-file``) as well
as by the running applications.
"""
from __future__ import annotations

import secrets
from pathlib import Path
from typing import Dict, List, Any

__all__ = ["EnvGenerator"]


class EnvGenerator:
    """Generate service environment variables and write them to disk."""

    _ENV_FILE_HEADER = (
        "# Generated by DynaDock\n"
        "# DO NOT EDIT MANUALLY â€“ this file will be overwritten.\n\n"
    )

    def __init__(self, env_file: str | Path = ".env.dynadock") -> None:
        self.env_file = Path(env_file)

    # ------------------------------------------------------------------
    # Public helpers
    # ------------------------------------------------------------------

    def generate(
        self,
        *,
        services: Dict[str, Any],
        ports: Dict[str, int],
        domain: str,
        enable_tls: bool,
        cors_origins: List[str],
    ) -> Dict[str, str]:
        """Return *env_vars* and write them to *env_file*."""

        env_vars: Dict[str, str] = {
            "DYNADOCK_DOMAIN": domain,
            "DYNADOCK_PROTOCOL": "https" if enable_tls else "http",
            "DYNADOCK_ENABLE_TLS": str(enable_tls).lower(),
            "DYNADOCK_CORS_ORIGINS": ",".join(cors_origins)
            if cors_origins
            else f"http://localhost:3000,http://localhost:5173,https://*.{domain}",
        }

        for service_name, port in ports.items():
            upper_name = service_name.upper().replace("-", "_")
            env_vars[f"{upper_name}_PORT"] = str(port)
            env_vars[f"{upper_name}_HOST"] = "0.0.0.0"
            env_vars[f"{upper_name}_URL"] = f"{env_vars['DYNADOCK_PROTOCOL']}://{service_name}.{domain}"
            env_vars[f"{upper_name}_INTERNAL_URL"] = f"http://{service_name}:{port}"

            # Database-specific helpers
            if any(db in service_name.lower() for db in ("postgres", "mysql", "mongo", "redis")):
                self._add_database_vars(env_vars, service_name, port)

        # Security secrets
        env_vars["DYNADOCK_SECRET_KEY"] = secrets.token_urlsafe(32)
        env_vars["DYNADOCK_JWT_SECRET"] = secrets.token_urlsafe(32)

        # Finally, write to disk
        self._write_env_file(env_vars)
        return env_vars

    # ------------------------------------------------------------------
    # Internal helpers
    # ------------------------------------------------------------------

    def _write_env_file(self, env_vars: Dict[str, str]) -> None:
        """Write *env_vars* to *env_file* in a grouped layout."""
        groups = {
            "General": [],
            "Services": [],
            "Database": [],
            "Security": [],
        }

        for key, value in sorted(env_vars.items()):
            if key.startswith("DYNADOCK_"):
                groups["General"].append(f"{key}={value}")
            elif any(key.endswith(suffix) for suffix in ("_DSN", "_URI", "_DATABASE")):
                groups["Database"].append(f"{key}={value}")
            elif key.endswith("_PASSWORD") or key.endswith("_SECRET"):
                groups["Security"].append(f"{key}={value}")
            else:
                groups["Services"].append(f"{key}={value}")

        with self.env_file.open("w", encoding="utf-8") as fp:
            fp.write(self._ENV_FILE_HEADER)
            for group_name, lines in groups.items():
                if not lines:
                    continue
                fp.write(f"# {group_name}\n")
                fp.write("\n".join(lines))
                fp.write("\n\n")

    # ------------------------------------------------------------------
    # Database helpers
    # ------------------------------------------------------------------

    def _add_database_vars(self, env_vars: Dict[str, str], service: str, port: int) -> None:
        upper = service.upper().replace("-", "_")
        if "postgres" in service.lower():
            env_vars[f"{upper}_USER"] = "postgres"
            env_vars[f"{upper}_PASSWORD"] = secrets.token_urlsafe(16)
            env_vars[f"{upper}_DB"] = "app_db"
            env_vars[f"{upper}_DSN"] = (
                f"postgresql://postgres:{env_vars[f'{upper}_PASSWORD']}@{service}:{port}/app_db"
            )
        elif "mysql" in service.lower():
            env_vars[f"{upper}_USER"] = "root"
            env_vars[f"{upper}_PASSWORD"] = secrets.token_urlsafe(16)
            env_vars[f"{upper}_DATABASE"] = "app_db"
            env_vars[f"{upper}_DSN"] = (
                f"mysql://root:{env_vars[f'{upper}_PASSWORD']}@{service}:{port}/app_db"
            )
        elif "mongo" in service.lower():
            env_vars[f"{upper}_USER"] = "admin"
            env_vars[f"{upper}_PASSWORD"] = secrets.token_urlsafe(16)
            env_vars[f"{upper}_DATABASE"] = "app_db"
            env_vars[f"{upper}_URI"] = (
                f"mongodb://admin:{env_vars[f'{upper}_PASSWORD']}@{service}:{port}/app_db"
            )
        elif "redis" in service.lower():
            env_vars[f"{upper}_PASSWORD"] = secrets.token_urlsafe(16)
            env_vars[f"{upper}_URL"] = f"redis://:{env_vars[f'{upper}_PASSWORD']}@{service}:{port}/0"
