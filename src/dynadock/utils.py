"""Utility helpers for DynaDock.

Only lightweight helpers live here so that other modules can import them
without pulling in heavy run-time dependencies such as *docker*.
"""

from __future__ import annotations

from pathlib import Path
from typing import Optional

import yaml

__all__ = [
    "find_compose_file",
    "validate_compose_file",
    "cleanup_temp_files",
    "render_template",
]

_SEARCH_FILENAMES = (
    "docker-compose.yaml",
    "docker-compose.yml",
    "compose.yaml",
    "compose.yml",
)


def find_compose_file(start_dir: Path | str = Path.cwd()) -> Optional[str]:
    """Search *start_dir* and its parents for a docker-compose file.

    The search will climb up at most five directory levels to avoid an
    unexpectedly long walk up the filesystem tree. Returns the *absolute*
    path of the first compose file found or ``None`` if nothing is found.
    """
    current_dir = Path(start_dir).resolve()

    for _ in range(6):  # 0 .. 5  (six iterations -> depth 5 up)
        for fname in _SEARCH_FILENAMES:
            candidate = current_dir / fname
            if candidate.is_file():
                return str(candidate)
        if current_dir.parent == current_dir:  # reached filesystem root
            break
        current_dir = current_dir.parent
    return None


def validate_compose_file(compose_file: str | Path) -> bool:
    """Very light validation that *compose_file* looks like a compose YAML.

    We only ensure that the top-level YAML document is a mapping containing a
    ``services`` key whose value is also a mapping. The schema is *not*
    validated in depth – docker-compose will eventually do that for us.
    """
    try:
        with open(compose_file, "r", encoding="utf-8") as fp:
            data = yaml.safe_load(fp)
        if not isinstance(data, dict):
            return False
        services = data.get("services")
        return isinstance(services, dict)
    except Exception:  # pragma: no cover – best-effort validation
        return False


_TEMP_FILES = (
    ".dynadock-compose.yaml",
    ".env.dynadock",
)


def cleanup_temp_files(project_dir: Path | str) -> None:
    """Remove temporary artefacts generated by DynaDock during runtime."""
    project_path = Path(project_dir)

    # individual files
    for fname in _TEMP_FILES:
        file_path = project_path / fname
        if file_path.exists():
            try:
                file_path.unlink()
            except OSError:
                # Ignore failure – nothing critical
                pass

    # the hidden .dynadock directory which stores the Caddy config
    caddy_dir = project_path / ".dynadock"
    if caddy_dir.exists():
        import shutil

        try:
            shutil.rmtree(caddy_dir)
        except OSError:
            pass


def render_template(template_content: str, variables: dict) -> str:
    """Render a Jinja2 template with the given variables.

    Args:
        template_content: The template string to render
        variables: Dictionary of variables to substitute in the template

    Returns:
        The rendered template string
    """
    try:
        from jinja2 import Template

        template = Template(template_content)
        return template.render(**variables)
    except ImportError:
        # Fallback to basic string substitution if Jinja2 is not available
        result = template_content
        for key, value in variables.items():
            result = result.replace(f"{{{{ {key} }}}}", str(value))
        return result
