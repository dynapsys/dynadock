# DynaDock Usage Guide

## ðŸ“š Table of Contents
- [Basic Usage](#basic-usage)
- [Advanced Scenarios](#advanced-scenarios)
- [Working with Services](#working-with-services)
- [Environment Variables](#environment-variables)
- [Networking](#networking)
- [Scaling Services](#scaling-services)
- [Best Practices](#best-practices)

## Basic Usage

### Starting Services

```bash
# Basic start
dynadock up

# With HTTPS/TLS
dynadock up --enable-tls

# Custom domain
dynadock up --domain myapp.local

# Specific port range
dynadock up --port-range 3000-4000
```

### Stopping Services

```bash
# Stop all services
dynadock down

# Stop and remove volumes
dynadock down -v
```

### Viewing Logs

```bash
# All services
dynadock logs

# Specific service
dynadock logs api

# Follow logs
dynadock logs -f
```

## Advanced Scenarios

### 1. Development Environment with Hot Reload

```yaml
# docker-compose.yaml
version: '3.8'
services:
  app:
    build: .
    volumes:
      - ./src:/app/src  # Mount source code
      - /app/node_modules  # Preserve node_modules
    environment:
      - NODE_ENV=development
      - DEBUG=app:*
    command: npm run dev
```

```bash
# Run with live reload
dynadock up --enable-tls
```

### 2. Multi-Stage Deployment

```yaml
# docker-compose.yaml
version: '3.8'
services:
  app:
    build:
      context: .
      target: ${BUILD_TARGET:-production}
    environment:
      - ENV=${ENV:-production}
```

```bash
# Development
BUILD_TARGET=development ENV=dev dynadock up

# Staging
BUILD_TARGET=staging ENV=staging dynadock up --enable-tls

# Production
BUILD_TARGET=production ENV=prod dynadock up --enable-tls --domain prod.example.com
```

### 3. Database with Initialization

```yaml
# docker-compose.yaml
version: '3.8'
services:
  postgres:
    image: postgres:15
    environment:
      - POSTGRES_DB=${DB_NAME:-myapp}
      - POSTGRES_USER=${DB_USER:-user}
      - POSTGRES_PASSWORD=${DB_PASS:-password}
    volumes:
      - ./init.sql:/docker-entrypoint-initdb.d/01-init.sql:ro
      - ./seed.sql:/docker-entrypoint-initdb.d/02-seed.sql:ro
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $${POSTGRES_USER}"]
      interval: 10s
      timeout: 5s
      retries: 5

  app:
    build: .
    depends_on:
      postgres:
        condition: service_healthy
    environment:
      - DATABASE_URL=postgresql://${DB_USER}:${DB_PASS}@postgres:5432/${DB_NAME}
```

### 4. Microservices with Service Discovery

```yaml
# docker-compose.yaml
version: '3.8'
services:
  gateway:
    image: nginx:alpine
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      - auth
      - api
      - frontend

  auth:
    build: ./services/auth
    environment:
      - SERVICE_NAME=auth
      - SERVICE_PORT=3001
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3001/health"]

  api:
    build: ./services/api
    environment:
      - SERVICE_NAME=api
      - SERVICE_PORT=3002
      - AUTH_URL=http://auth:3001
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3002/health"]

  frontend:
    build: ./services/frontend
    environment:
      - API_URL=http://api:3002
      - AUTH_URL=http://auth:3001
```

## Working with Services

### Service URLs

After starting with DynaDock, services are accessible at:
- **HTTPS**: `https://<service-name>.<domain>`
- **HTTP**: `http://<service-name>.<domain>`

Examples:
```bash
# Service named 'api' with default domain
https://api.dynadock.lan

# Service named 'frontend' with custom domain
dynadock up --domain myapp.test
# Access at: https://frontend.myapp.test
```

### Port Mapping

DynaDock automatically assigns ports from the configured range:

```bash
# Check assigned ports
dynadock ps

# Output:
# SERVICE    STATUS    PORTS
# api        running   3001 -> https://api.dynadock.lan
# frontend   running   3002 -> https://frontend.dynadock.lan
```

### Health Checks

```yaml
# Recommended health check patterns
services:
  web:
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  api:
    healthcheck:
      test: ["CMD-SHELL", "wget --quiet --tries=1 --spider http://localhost:8080/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
```

## Environment Variables

### Auto-Generated Variables

DynaDock automatically generates these variables in `.env.dynadock`:

```bash
# Service URLs
API_URL=https://api.dynadock.lan
FRONTEND_URL=https://frontend.dynadock.lan

# Service Ports
API_PORT=3001
FRONTEND_PORT=3002

# Database Credentials (if applicable)
DB_PASSWORD=<auto-generated>
REDIS_PASSWORD=<auto-generated>
```

### Using Custom Variables

```bash
# .env.custom
NODE_ENV=development
DEBUG=true
API_KEY=your-secret-key

# docker-compose.yaml
services:
  app:
    env_file:
      - .env.custom
      - .env.dynadock  # Auto-generated by DynaDock
```

## Networking

### Internal Service Communication

Services can communicate using service names:

```javascript
// In your application code
const apiUrl = process.env.NODE_ENV === 'production' 
  ? 'https://api.example.com'
  : 'http://api:3000';  // Internal Docker network

fetch(`${apiUrl}/users`)
  .then(res => res.json())
  .then(data => console.log(data));
```

### External Access

```yaml
# Allow CORS for external access
services:
  api:
    environment:
      - CORS_ORIGINS=https://app.example.com,http://localhost:3000
```

```bash
# Start with CORS configuration
dynadock up --cors-origins "https://app.example.com,http://localhost:3000"
```

## Scaling Services

### Horizontal Scaling

```bash
# Scale a service to 3 instances
dynadock up --scale api=3

# Or in docker-compose.yaml
services:
  api:
    deploy:
      replicas: 3
```

### Load Balancing

When scaled, Caddy automatically load balances between instances:

```bash
# Requests to https://api.dynadock.lan are distributed across all instances
curl https://api.dynadock.lan/health
```

## Best Practices

### 1. Use Health Checks

Always define health checks for production readiness:

```yaml
healthcheck:
  test: ["CMD", "curl", "-f", "http://localhost:${PORT}/health"]
  interval: 30s
  timeout: 10s
  retries: 3
  start_period: 40s  # Time for service to start
```

### 2. Optimize Docker Images

```dockerfile
# Multi-stage build
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

FROM node:18-alpine
WORKDIR /app
COPY --from=builder /app/node_modules ./node_modules
COPY . .
EXPOSE 3000
CMD ["node", "server.js"]
```

### 3. Use Named Volumes

```yaml
volumes:
  postgres_data:    # Named volume (persistent)
  redis_data:       # Named volume (persistent)
  
services:
  postgres:
    volumes:
      - postgres_data:/var/lib/postgresql/data  # Good
      # - ./data:/var/lib/postgresql/data       # Avoid for databases
```

### 4. Secure Secrets

```yaml
# Use environment variables for secrets
services:
  app:
    environment:
      - DB_PASSWORD=${DB_PASSWORD}  # From .env file
      - API_KEY_FILE=/run/secrets/api_key
    secrets:
      - api_key

secrets:
  api_key:
    file: ./secrets/api_key.txt
```

### 5. Resource Limits

```yaml
services:
  app:
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 512M
        reservations:
          cpus: '0.25'
          memory: 256M
```

## Common Use Cases

### WordPress Site

```yaml
version: '3.8'
services:
  wordpress:
    image: wordpress:latest
    environment:
      - WORDPRESS_DB_HOST=mysql
      - WORDPRESS_DB_USER=wordpress
      - WORDPRESS_DB_PASSWORD=${DB_PASSWORD}
      - WORDPRESS_DB_NAME=wordpress
    depends_on:
      - mysql

  mysql:
    image: mysql:8.0
    environment:
      - MYSQL_ROOT_PASSWORD=${DB_ROOT_PASSWORD}
      - MYSQL_DATABASE=wordpress
      - MYSQL_USER=wordpress
      - MYSQL_PASSWORD=${DB_PASSWORD}
    volumes:
      - mysql_data:/var/lib/mysql

volumes:
  mysql_data:
```

```bash
dynadock up --enable-tls --domain myblog.local
# Access at: https://wordpress.myblog.local
```

### Python Flask API

```yaml
version: '3.8'
services:
  api:
    build: .
    environment:
      - FLASK_ENV=development
      - DATABASE_URL=postgresql://user:pass@postgres:5432/app
    depends_on:
      - postgres
      - redis

  postgres:
    image: postgres:15-alpine
    environment:
      - POSTGRES_PASSWORD=${DB_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:
```

```bash
dynadock up --enable-tls
# Access at: https://api.dynadock.lan
```
